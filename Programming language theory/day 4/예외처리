10.2 예외 및 예외처리

예외: 심각하지 않은 오류 혹은 비정상적 상황

예외가 발생하면 이를 처리하고 프로그램이 정상 작동하도록 해야한다.
보통 발생된 예외를 처리하지 못하면 프로그램은 종료한다.
따라서 안전한 실행을 위해 예외처리는 중요하다.

예외 정의 : 프로그래머가 새로운 예외를 정의할 수 있는 기능
예외 발생 : 예외를 발생시킬 수 있는 문장
예외 처리 : 발생된 예외를 처리하기 위한 문장

예외처리모델
예외 처리와 그 후의 흐름을 확인한다.
try{}
catch{}
구문 : try에서 예외가 발생하면 catch에서 예외를 처리한다.

재개모델 : 예외가 발생하면 발생 지점으로 돌아가서 예외 처리를 하고 그 곳에서 재개한다.
종료모델 : 예외가 발생하면 예외를 처리하고 발생지점으로 가지 않고 try문을 종료해버린다. 다음 문장으로 넘어간다.

예외를 해결하지 못하는 경우 catch문을 수행하지 못하고 넘어가 버린다.
종료모델이 우수하다.

언어 s의 예외

1. exc : 얘로 시작하는 선언은 새로운 예외이름을 정의하는 기능으로 마치 전역 변수를 선언하는 것과 같다. 특정한 예외 상황을 부르는 말이다.
ex) exc id
2. raise : 어떤 특정한 상황에서 해당 예외를 발생시키는 문장이다. 발생 예외 처리 불가시 프로그램 종료
ex) raise id
3. try-catch : try실행 중 발생한 문장의 예외를 catch에서 처리한다. 발생된 예외이름과 처리한 예외이름이 같으면 두번째문장을 실행하여 예외를 처리한다.
ex) tey <stmt> catch (id) <stmt>
4. 함수 내에서 발생한 예외는 함수 내에서 처리되어야한다. 처리 불가시 프로그램은 종료된다.

어떤 문장 S1을 실행할 때 발생할 수 있는 예외의 종류에 따라 다르게 처리한다면 catch 절을 사용하는게 좋다.

try
  S1
catch(E1) S2
catch(E2) S3

이런식으로  catch 절이 두개있는 문장은 사실 다음과 같이 try문을 중첩하여 작성할 수 있으며 이것에 대한 일종을 설탕 구문이라고 할 수 있다.
try블록에는 어떤 문장도 들어올 수 있기 때문에 try 블록 내에 또 try블록이 올 수 있다.

try
  try
    S1
  catch(E1) S2
catch(E2) S3

10.2 python 예외

발생한 예외를 처리하려면 다음과 같이 try 절에 실행코드,catch절에 예외처리코드를 넣어두면 된다.
 try
    실행코드
except 
  예외처리코드

10을 0으로 나누었을 때 발생하는 예외

try:
 x=int(input('나눌 숫자를 입력하세요 : '))
 y=10/0
 print(y)
except:
 print('예외가 발생했습니다.')

ZeroDivisionError 가 발생한다.
except절에서 이 예외를 처리하고 예외가 발생했습니다를 출력한다.
특히 예외가 발생하면 바로 중단하고 예외 처리 절로 가서 예외를 처리한다.
바로 프로그램을 종료하기 때문에 다른 문장들은 처리되지 않는다. 

특정 예외 처리

앞에서와 같이 except를 사용하는 경우 어떤 예외도 처리할 수 있지만 각 예외에 맞는 적절한 처리가 불가능하다는 것이다. 
여기에 예외 이름을 지정하면 보다 적절한 처리가 가능하다.
except를 여러개 사용 가능한데 이렇게 되면 try절에서 발생하는 다양한 예외를 적절하게 처리할 수 있다.
else와 finally절은 try절에서 예외 발생 여부와 관계 없이 마지막으로 실행된다.

try:
  실행코드
except 예외이름:
  예외 처리 코드 
...
except 예외이름:
  예외 처리 코드 
else:
  예외가 발생하지 않았을 경우 실행할 코드
finally:
  예외 발생 여부와 관계없이 실행되는 코드

예외처리 코드가 없는 경우 어떻게 되나?
-> 예외처리가 되지 않고 try문을 빠져나오게 된다.실행시간 오류도 발생한다. 오류메세지가 출력되고 프로그램 실행이 중단된다.

try문 중첩
-> try문에서 처리되지 않고 빠져나온 애는 그 바깥쪽에 try문이 있는 경우에는 바깥쪽을 한 번 더 돌게 되고 거기서 처리될 수도 있다.
바로 오류 뜨는 것은 아님

예외의 오류 메세지

특히 try문의 except절에서 다음과 같이 as 뒤에 변수를 저장하면 이 변수에 발생한 예외 오류 메세지를 받아올 수 있다.

except 예외이름 [as 변수] :
  예외처리코드

변수를 하나 아무거나(보통은 e로) 설정한다.
여기에 오류 메세지를 설정한다. e에 저장된 메세지를 출력한다.

finally 절
try 구문의 마지막 절

예외 전파
예외가 코드 블록안에서 발생한 경우 예외는 가장 가까이에 있는 try문이 처리하게되는데 실패시 그 밖의 가장 가까운 try문으로 전파된다.
이와 비슷하게 호출된 함수 내에서 발생한 예외는 그 함수 내에서 처리되지 않으면 호출자 함수에 전파된다.

예외 계층 구조
python에서 예외는 클래스 상속으로 구현되며 보통 새로운 예외를 만들 때는 Exception을 상속받아서 구현한다.
최상위 예외 클래스 : BaseException 이나 그에 준하는 Exception등을 except 절에 지정하면 발생하는 모든 예외를 처리할 수 있다.
예를 들어 
try                      try
...                      ...
except BaseException:     except:

except 여기서 받는 예외는 정의되지 않는 예외들 = 모든 예외들을 처리할 수 있다.

예외 발생과 예외 정의 
프로그램에서 예외적인 상황을 만나게 되면 일주로 예외를 발생시킬 수 있다. python은 raise 명령어를 사용해 다음과 같이 예외를 발생시킬 수 있다. 
이 경우에 예외 이름은 이미 정의된 내장된 예외 이름도 가능하고 사용자가 정의한 예외이름도 가능하다.

raise 예외이름
raise 예외이름(메세지)

프로그래머는 프로그램 수행중에 특수한 예외적인 상황에 맞게 적절한 예외처리를 하기위해서 이에 맞는 새로운 예외를 정의해서 사용하면 된다.
직접 예외를 정의해 보자. Exception 클래스를 상속하여 음수입력을 나타내는 새로운 예외 
class NegativeInputException(Exception):
  pass

오류메세지의 오류
프로그램을 실행하다가 보면 print(e)로 메세지가 출력되지 않는 경우가 존재
이럴때는 예외 클래스에 다음과 같은 __srt__ 메소드를 구현하는 것이다.
class NegativeInputException(Exception):
  def __srt__(self):
    return "음수 입력입니다."

이렇게 따로 메세지 출력을 만들어줘야한다.

10.3 java 예외

예외 선언 
예외를 클래스로 선언한다. 단지 이름만으로 선언하지 않고. 새로운 예외를 정의하는 클래스는 Exception 클래스나 그 서브 클래스로부터 상속받아 정의해야 하며
다른 클래스 처럼 생성자, 멤버 필드, 메소드 등을 가질 수 있다.
예외를 나타내는 객체는 다른 일반 객체처럼 사용될 수 있다. 즉 객체처럼 클래스를 이용하여 정의되고 일반 객체처럼 사용될 수 있다.
*차이점 : 예외 객체는 throw되어 에외를 발생시킬 수 있다는 점이다.

예외 클래스들 사이의 클래스 계층구조

최상위 : odject 
모든 객체가 가져야하는 공통적 속성들을 정의하고 있다.

하위 클래스 : throwable
오류같은 throw 될 수 있는 객체를 정의하는 클래스이다.
Exception은 throwable 하위 클래스이며 모든 예외 클래스의 조상이 된다.

따라서 예외를 정의하는 모든 클래스는 이 Exception 클래스를 직간접적으로 상속받는다.

비검사 예외
0으로 나누는 경우 발생하는 예외로 runtimeException

새로운 예외를 클래스로 정의하려면 이 Exception 클래스를 상속받아 정의해야한다. 
어떻게?
public class NegativeInputException extends Exception{
  private String reason = "Negative Input";
  NegativeInputException(){
    System.out.println(reason+"is received")
  }
}

예외 발생 및 처리

java에서는 throw문을 이용해서 예외를 발생시키는데

throw 예외 객체;
이런느낌으로 

예외를 발생시키는 throw 문은 메소드 헤더에 처리되지 있는 예외를 선언하는 throws와는 다르다는 점을 유의하기 바란다.(이 선언은 10.3에서 자세히 설명)
발생된 예외를 처리하지 않는 경우 프로그램은 메세지를 내고 종료한다.
이 메세지는 호출 스택 트레이스를 포함하고 main 메소드로부터 예외가 발생할 때까지 메소드 호출 과정을 보여준다.

발생된 예외는 다음과 같은 try-catch문을 이용하여 처리할 수 있다.
보통 예외가 발생할 수 있는 실행 문장들은 try블록에 작성한다. 이 블록을 작성할 때 예외가 발생하면 다음과 같이 처리된다.
1. 발생된 예외를 순차적으로 catch과 매치하여 처음 매치되는 catch 절이 실행되어 발생된 예외를 처리한다.
2. 매치되는 catch 절이 없으면 이 문장에서 예외가 발생하였으나 처리되지 않은 것이다.
3. 만약 try블록에서 예외가 발생하지 않으면 이 문장 다음에 오는 문장이 실행된다.

try-catch 문에 옵션으로 finally 절이 포함된다.

예외 전파
호출의 역순으로 전파가 발생하여 예외를 처리하려고 한다.


10.4 예외 검사 및 예외 선언

예외 검사의 필요성
프로그램 내에소 예외가 발생할 수 있는 코드가 있으면 이를 처리하기 위한 try-catch문이 있어야하는데 이 문이 없으면 실데 실행에서 오류가 발생할 것이다.
이를 막기위해서 예외검사가 필요하다.

java에서는 이를 막기위해 컴파일러가 이를 미리 검사한다.
컴파일러는 원래 예외가 발생할 수 있는 곳에 이를 처리할 수있는 try-catch문이 있는지 미리 검사하고 처리할 수 있는 문장이 없으면 컴파일 오류를 낸다.

처리되지 않은 예외의 선언
예외검사와 관련해 주의할 것 : 꼭 예외가 발생한 그 메소드 안에서 처리할 필요가 없다. 예외전파를 통한 해결도 가능하다.따라서 예외 발생 메소드 안에 
try-catch문이 없다고 반드시 오류가 발생하는 것은 아니다.

해결방안
java에서는 메소드 안에서 예외처리를 의도적으로 안하는 경우도 존재 > 이런경우는 메소드 헤더에 관련 코드를 작성해줘야한다.
throws이용해서 메소드 헤더에 추가하기
메소드이름()throws E1 {

}
이 메소드에서 여러종류의 예외처리가 가능하다.
메소드이름()throws E1, E2, E3, E4{

}


예외 검사
java 컴파일러는 프로그램 내에서 발생한 예외가 처리될 수 있는지 컴파일 시간에 미리 검사를 미리 검사를 실시하는데 이를 예외검사라고 한다. 
java 컴파일러 예외 검사를 통해 어떤 메소드 내에서 발생가능한 예외가 해당 메소드 내에서 처리될 수 있는지 아님 메소드 헤더에 선언되었는지 검사한다.
1. 어떤 메소드 내에서 발생가능한 예외가 해당 메소드 내에서 try-catch문으로 처리될 수 있는지
2. 아니면 메소드 헤더에 throws 절에 선언되었는지 검사한다.

둘중 하나라도 가능하면 오류가 아니다. -> 둘다 없으면 오류임

조금 더 구체적으로 말하자면 
메소드 내에서 다른 메소드를 호출하는 겨웅 피호출자 메소드 헤더에 throws 절로 선언된 정보들을 참조하여 이 예외를 처리할 수 있는 try-catch문이 존재하는 지 확인
-> 없다면 호출자의 메소드 헤더에 이 예외가 선언되었는지 확인
-> 해결될 때까지 이것을 반복

검사 예외와 비검사 예외
예외검사의 문제점은 정말 모든 예외에 대한 처리가 가능한가에 대한 의문이 있는 것이다.
모든 경우를 처리하는 것은 부담이 될 수 있음 -> 컴파일러는 컴파일 시간의 예외만 처리하고 실행시간과 관련된 예외는 프로그래머에서 처리를 위임
이 때 검사 여부에 따라 검사 예외, 비검사 예외로 나뉜다.

검사 예외 : 예외가 발생하는 경우 이를 처리할 수 있는 처리문이 있는지 확인한다. 컴파일러가 미리 검사하는 예외로 runtimeException 예외를 제외한 예외는 모두 검사 예외이다.
메소드 내부에서 처리되지 않는 예외는 메소드 헤더 부분에 throws를 사용하여 선언되어야한다.
비검사 예외 : runtimeException로부터 상속받는 표준 런타임 예외들로 컴파일러가 예외검사를 하지 않는다. 프로그래머가 직접 코드를 작성해서 예외를 처리하도록 해야한다.




요약
재개 모델 : 예외가 발생하면 예외처리 후 예외를 발생시킨 코드로 재개하여 계속 실행한다.
종료 모델 : 예외가 발생하면 예외 처리 후 예외를 발생시킨 코드로 재개하지 않고 try문을 끝내고 다음문장을 실행한다.

예외전파 : 호출된 함수에서 발생한 예외는 그 함수 내에서 처리되지 않으면 호출의 역순으로 처리될 때까지 호출자 함수에게 전파
java 컴파일러는 예외 검사를 통해 어떤 메소드 안에서 발생 가능한 예외가 해당 메소드 내에서 처리 가능한지 아닌지 아니면 메소드 헤더에 선언되었는지 검사한다.
검사 예외 : 예외가 발생한 경우 이를 처리할 수있는 처리문이 있는지 컴파일러가 미리 검사하는 예외
runtimeExpectation을 제외한 모든 예외는 모두 검사 예외이다.
메소드 내에서 처리되지 않는 예외는 메소드 헤더 부분에 throws를 이용하여 선언되어야한다.
비검사 예외 : 컴파일러에서 처리되지 않는 런타임 시간들의 예외 사항으로 프로그래머가 따로 코드를 작성해서 처리해야한다.
