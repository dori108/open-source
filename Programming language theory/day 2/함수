8.1 함수 정의

함수는 인자를 받아 return 값을 내보냄
함수 만들기 -> 호출 기능을 이용해서 사용한다.
리턴 값이 없는 함수도 사용이 가능하다.
바로 print 해버리는거지

프로시저 : 리턴 값이 없는 함수
대신 매개변수나 비 지역변수를 사용해서 계산 결과를 나타낸다.

함수 정의

헤더 : 리턴 타입, 변수 이름, 매개변수를 선언
리턴 타입이 void이면 프로시저 그외의 것이면 그 값을 리턴하는 함수가 되는 것이다.
본체 : 
매개변수 : 인자를 받아와서 함수 안에서 계산을 하게 하는 변수이다.
함수 호출 : 함수 이름과 인자들로 구성 print문에서 호출하거나 추가 작업을 위해서 (리턴값 없는 프로시저) 이용한다.
인자를 해당 매개 변수로 저장해서 식을 계산한다. 블럭단위로 만들어진 함수와 main을 구분해야한다.
인자 : 수식의 값
리턴문 : 리턴값이 있는 경우 그 하나의 숫자로 고정된다.

타입 없는 함수 정의

js, python은 따로 함수 정의 없이 사용이 가능하다.
매개변수 타입이나 리턴타입을 결정해줄 필요가 없다.
def 이용함수 정의

def 함수이름(매개변수):
  함수 본체

호출 방법 : 함수이름(인자)

사례연구
c/c++, java : 오직 함수만 있고 프로시저는 리턴 타입이 void인 함수이다.

python, js : 프로시저와 함수를 따로 구분함. 


8.2 매개변수 전달

함수 호출에 사용된 매개변수는 실매개 변수 = 인자라고 불리기도 한다.
ex) c= max(a,b)
a,b :실매개변수
max() : 함수

반면 다음과 같은 함수 정의에서 사용된 매개변수는 형식 매개변수이다.
<function>-> fun <type> id(<para>) <stmt>
<para>-> <type> id {,<type> id}

실매개변수 (Actual Parameter or Argument):
함수 호출 시 전달되는 실제 값 또는 변수.
예시: max(a, b) 호출에서 a와 b.

형식 매개변수 (Formal Parameter):
함수 정의 시 선언되는 매개변수로, 함수 내부에서 사용될 변수의 이름과 타입을 지정.
예시: int max(int x, int y) 정의에서 x와 y.

#include <stdio.h>

int add(int x, int y) {  // x와 y는 형식 매개변수
    return x + y;
}

int main() {
    int a = 10;
    int b = 20;
    int result = add(a, b);  // a와 b는 실매개변수
    printf("%d\n", result);  // 출력: 30
    return 0;
}

함수호출이 발생하면 인자의 값을 매개변수 값으로 대치 시켜야하는데
이것을 매개변수 전달이라고 한다. 

매개변수 전달 
값전달 : 가장 간단, 거의 모든 언어의 기본적인 전달 방법
1. 수식인 인자 값들을 계산한다.
2. 계산된 값을 대응되는 매개 변수로 전달한다.
3. 함수 실행

값전달은 값의 변동이 생기면서 함수가 사용되기 때문에 원치 않은 값을 도출하는 경우가 있다. (temp) 

참조 전달 : 함수를 호출할 때 인자가 아닌 인자의 참조를 호출한다.
주소, 포인터라는 의미가 있는 참조 
작동 방식
1. 함수 호출시 인자의 위치가 계산되어 매개변수에 전달된다. -> 위치를 할당받은 인자여야만 한다.
2. 함수 내에서 매개변수를 사용하면 자동주소참조가 이루어지는데 대응되는 인자를 접근하게 된다.
3. 매개변수 값을 변경하면 자동적으로 대응되는 인자값이 변경된다.
참조 전달을 이용하여 매개변수를 전달하면 인자와 대응되는 인자값이 변경된다.
한 기억 장소에 대한 두개의 이름이 생기는 것이다. 
주로 c언어에서 많이 사용된다.
c는 참조 전달이 제공되지 않지만 포인터를 제공하기 때문에 같은 역할을 한다.
*를 이용해서 주소를 전달 받는다. 이를 통해 swap 함수 작성이 가능

include <stdio.h>

int main() {
    int a = 10;
    int b = 20;
    
    int *p = &b;  // p에 b의 주소를 저장
    a = *p;      // p가 가리키는 값을 a에 저장

    printf("%d\n", a);  // 출력: 20

    return 0;
}

void swap(int *px, int *py){
  int t;
  t =*px;
  *px = *py;
  *py = t;
}

참조 전달의 문제점
하나의 주소에 두가지 이름이 붙어 있으면 어떤 것을 의미하는지 파악하기 어렵다 -> 의미 파악 불분명

값-결과 전달 : 함수를 호출할 때 함수로부터 리턴할 때 두번 매개변수를 전달한다.
첫번째 전달이 값, 두번째 전달이 결과 전달이 된다.
1. 함수 호출시 : 인자 값을 매개변수에 붙여넣는다.
2. 함수 리턴시 : 매개변수값을 역으로 인자에 붙여넣는다.


이름 전달 : 아무것도 전달하지 않는다. 변수가 사용될 때까지 계산되지 않고 매개변수가 사용될 때 비로소 계산된다.
1. 인자는 대응되는 매개변수가 사용될 때 까지 계산되지 않고 기다린다.
2. 매개변수를 인자이름으로 대치하고 실행한다고 생각할 수 있다.

바로바로 따와서 적용시킨다고 생각하면 될 것 같다. 원래 i=1이 었더라도 i+=1이 나오면 다른 턴에 +1이 되는 것이 아니고 바로 적용되는 것이다.


8.3 함수와 바인딩

속성 = 바인딩 정보 : 유효한 변수와 함수 이름에 대한 정보들
 
유효범위규칙
선언된 변수가 사용가능한 범위

동적 : 유연하게 움직이는데 가장 가까이 있던 변수가 적용된다.
정적 : 딱 그 문 안에서만 적용 가능 함수, let 문 등을 나가게 되면 전역변수를 적용시키지 지역변수는 봐주지도 않는다.
어떤 규칙을 적용하느냐에 따라 결과가 달라진다.

바인딩과 심볼

바인딩 : 어떤 속성과 이름을 연결시키는 것
보통 변수, 상수, 함수 등을 이름/식별자와 연결 시킨다.

정적 바인딩 : 컴파일 시간에 한번에 바인딩이 이루어지고 이후에는 변화하지 않는다.
동적 바인딩 : 실행 중에 바인딩이 이루어진다. 실시간으로 연결되는 속성들이 바뀔 수 있다.
컴파일러나 인터프리터는 특정 시점에서 유효한 속성들을 유지한다. 바인딩을 이용해서

그럼 바인딩은 매치 시키는거라고 해. 저장은 어디에 되는걸까?
그것이 바로 심볼테이블
유지관리를 위한 자료구조이다.
변수이름/식별자
변수의 타입
유효범위, 값 등을 저장한다.

유효 범위를 저장하는 자세한 방법은 이후에 배울 것


8.4 함수의 타입 검사

함수를 위한 타입 규칙을 세워보자

fun bool f(int x)
  if (x>0) then return 1;
else return 0;

bool값을 리턴하는 함수로 정의해두고 리턴값은 정수다. 따라서 오류가 발생해
-> 해결하려면 0,1 아니고 false true를 반환하면 된다.

1. 함수는 헤더에 선언된 것 처럼 정의되어야한다.

함수의 매개변수를 하나라고 가정했을 때
fun t1 f(t1 id) S 라는 함수가 있다고 하자.

매개변수 id는 t1타입이고 S는 t2 타입 이어야한다. 그래야 선언된 것처럼 함수 전체가 t2의 타입을 가질 수 있다.
이후에 이것이 맞는지 검사를 해보면 되겠지만.
이를 위해 매개변수로 선언된 id의 타입t1을 타입 환경에 추가하고 규칙을 수정한다. 
이렇게 했을 때 옳게 도출되는지 확인하면 된다.


함수 정의의 타입 오류
분석할 때
덩어리 단위로 쪼개서 하는거 알지? 변수는 하나까지 최대한 쪼개서 트리 만들어서 분석한다.

재귀함수 정의의 타입 규칙
함수 정의 내부에서 매개변수 id뿐 아니라 함수이름 f도 유효해진다. 계속 반복되기 때문이지
이들에 대한 타입 정보도 타입 환경에 추가해야한다.
그리고 검사를 시작해야한다.

함수 호출의 타입규칙
1. 호출 함수가 유효한 이름이어야한다.
2. 함수 호출에서 인자는 선언된 매개변수와같은 타입이어야한다.
3. 함수 호출에서 결과값의 타입은 리턴값의 타입이 된다.

함수의 타입 정보가 타입환경에 저장되는 모양을 잘 확인하기

8.5 함수 구현

파싱과 ast
함수 정의 : 하나의 명령어 형태로 선언된다. 
함수 정의에 대한 파싱은 또다른 함수를 통해서 구현될 수 있다.
이 함수는 파싱한 함수 정의에 관한 ast를 리턴한다.
함수는 리턴타입, 함수이름, 매개변수 선언, 실행 문장 증으로 구성되기 때문에 함수 정의의 ast는 다음과 같이 정의된다.
ast : function/id, type, stmt, decls

함수 호출

함수 호출의 구문법을 따라서 파싱을 할 수 있다.
호출의 ast는 다음과 같이 표현된다.
ast : call/ id, exprs

이들은 하나의 간단한 클래스로 표현이 가능하다.

리턴문의 ast
return/id, exprs

함수의 타입 검사

리턴문 : 리턴문에서 반환할 값을 나타내는 수식의 타입은 임의의 타입이 가능하다.
함수 정의에 관련한 : 함수 본체가 헤더에 선언한 그것을 따라야한다. 아까 했던 대호 전체 함수 가 t2 타입이기 위해서 id가 t1일 때 S는 t2여야한다.
함수 타입에 관련한 검사 구현은 먼저 함수에 선언된 타입들 및 매개변수 등의 타입을 타입환경에 추가한 뒤에 이루어진다. 본체를 먼저 확인한 뒤 이 타입에 선언된 리턴타입까지 일치하는지 마지막으로 확인한다.
마지막으로 정의된 함수에 추가된 새로운 타입을 추가해준 후 리턴 타입 일치 여부를 확인해준다.
함수 호출에 관련한 : 함수 호출의 경우 먼저 함수 이름이 유효한지가 확인 되어야한다.
함수 호출에서 사용되는 인자의 타입과 대응되는 매개변수 타입이 같은지 검사하고 조건이 만족하면 함수 호출의 결과는 리턴타입과 동일하게 맞춰진다.

-> 직접 손으로 여러번 써보는 작업이 필요한 부분이야.

요약 

정적유효범위 규칙 : 유효 범위가 정적이다. 컴파일 시간안에 모든것이 결정되기 때문에 실행중에 변화가 불가능하다.
그 함수를 벗어나면 안에서 정의된 식별자는 이용되지 못하고 전역 변수를 대신 이용하게 된다. 선언된 블록 안에서만 유효하다.

동적유효범위 규칙 : 실행 중에도 유효 범위가 변동이 있다. 함수를 벗어나도 가장 가까운 변수를 참조하는 경우가 존재한다.
선언된 이름은 선언된 블록의 실행이 끝날 때까지 유효하고 유지된다. 실행 경로에 따라 유효 범위가 달라질 수 있다.

바인딩 : 일반적으로 바인딩은 이름과 속성을 연결하는 것이다. 이름과 속성을 연결하는 작업이다.

동적 바인딩 : 실행 시간에서도 바인딩이 가능하다. 이미 속성이 정해졌다 하더라도 얼마든지 바뀔 수 있다.
정적 바인딩 : 컴파일 시간에 확정이 되면 변동 불가하다.

심볼테이블
이름 값 타입 등의 식별자의 속성이 저장되는 곳이다. 

값 전달 방식 : 함수를 호출 할 때 값 자체를 전달하는 것. temp를 못한다는 단점이 있다.
값 - 결과 전달방식 : 값을 전달해서 수행을 하고 완성본을 원본에 가져다가 붙인다. 매개변수의 전달이 두 번 있다. 첫번째 전달이 값전달, 둘 째가 결과 전달이다.
참조 전달 방식 : 포인터와 같다 주소를 따온다. 하나의 값에 이름이 여러개 존재해 헷갈린다는 문제가 있다. 값이 아닌 인자의 주소를 참조한다.
이름 전달 방식 : 한줄한줄 읽는 것 같다. 처음에 i=0이었더라도 실행 중에 i=1로 바뀌면 다음 턴이 아니라 이번 턴에서 반영하여 결과를 도출한다.
