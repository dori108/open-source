9.1 함수 호출 구현의 원리 

함수호출을 위해 필요한 자료구조 및 해야할 일을 정리해보자
1. 매개변수를 위한 기억장소할당
2. 반환값을 위한 기억장소할당
3. 반환주소를 위한 기억장소할당 및 저장
4. 피호출자 시작 부분으로 제어 이전
-> 먼저 기억장소할당이 되고 이후에 로직 관련된 구조가 나오고 있네

호출로부터 반환하기 위해서는 어떤 것이 필요할까?
1. 지역, 매개 변수 등을 위한 기억장소 해제 -> 할당을 위해 헤재 또한 필요하다.
2. 반환값 저장 -> 다시 저장도 해야지
3. 호출자로 변환 -> heap에 만들어진 영역을 반환하는 법

또한 함수에는 재귀도 있기때문에 고려해줘야한다.
재귀는 몇번 반복될지 모르는 애기 때문에 미리 구성할 수가 없다. 호출될 때마다 구조를 만들어야하는 것이다.
호출될 때 마다 매개변수 n에 대한 기억장소를 할당해야한다.


실행시간 스택
위에서 말한 것과 같이 여러 정보 저장을 위해서는 자료구조가 필요한데 실행될 때마다 바로바로 만들어져야한다.
이때 쓰는 것이 스택
스택은 lifo 구조로 쓰고 남은 스택은 바로바로 버리도록 구조화되어있어 저장공간 할당을 많이 하더라도 비교적 무리가 덜간다.
여러 함수들 사이를 참조하는 경우나 재귀함수처럼 자신을 여러번 참조하는 경우 모두 lifo구조에 따른다.

활성 레코드 : 스택이 저장되는 공간
함수 호출을 구현 하기 위한 자료구조는 스택프레임 = 활성 레코드라고 부른다. 그냥 이름이 다른거니까!
함수호출 구현하기
1. 함수 호출될 때마다 새로운 프레임에 스택을 생성한다.
2. 함수호출이 끝날 때마다 호출된 프레임을 제거한다.

여기에는 지역변수 매개변수 반환값 반환주소등 여러 정보가 들어간다.

스택에서 피호출자 활성레코드 바로 아래에 있는 활성레코드를 호출자 활성레코드라고 한다. 곧 불리고 없어질 애라서 호출자라고 불리나보다
스택 구조는 다음과 같이 메모리가 구분된다
반환 값
지역변수
매개변수 -> 전달 매커니즘 : call by value / result -> 전달되는 방식을 위해 필요한 것들
반환주소(에 저장) -> 나를 불러준 함수, 활성 레코드로 돌아간다.
제어링크 

이렇게 구성이 되어있다. 제어링크는 피호출자 레코드 바로 아래에 위치해 다음 호출자인 레코드를 가리킨다.

그 다음 

정적영역
stack
heap

이렇게 나눠져 있는데
heap은 버퍼 역할을 한다. stack과 heap은 영역을 처리하는 비율이 반비례한다.

1. 인터프리터 : 목적코드 사용 안함
2. 컴파일러 : 목적코드 사용 
두개로 나눠서 구분할거야
-> 뭐가 중요해? 메모리 사용법이 상이해짐


호출
활성레코드
stack에 들어감 


























