9.1 함수 호출 구현의 원리 

함수호출을 위해 필요한 자료구조 및 해야할 일을 정리해보자
1. 매개변수를 위한 기억장소할당
2. 반환값을 위한 기억장소할당
3. 반환주소를 위한 기억장소할당 및 저장
4. 피호출자 시작 부분으로 제어 이전
-> 먼저 기억장소할당이 되고 이후에 로직 관련된 구조가 나오고 있네

호출로부터 반환하기 위해서는 어떤 것이 필요할까?
1. 지역, 매개 변수 등을 위한 기억장소 해제 -> 할당을 위해 헤재 또한 필요하다.
2. 반환값 저장 -> 다시 저장도 해야지
3. 호출자로 변환 -> heap에 만들어진 영역을 반환하는 법

또한 함수에는 재귀도 있기때문에 고려해줘야한다.
재귀는 몇번 반복될지 모르는 애기 때문에 미리 구성할 수가 없다. 호출될 때마다 구조를 만들어야하는 것이다.
호출될 때 마다 매개변수 n에 대한 기억장소를 할당해야한다.


실행시간 스택
위에서 말한 것과 같이 여러 정보 저장을 위해서는 자료구조가 필요한데 실행될 때마다 바로바로 만들어져야한다.
이때 쓰는 것이 스택
스택은 lifo 구조로 쓰고 남은 스택은 바로바로 버리도록 구조화되어있어 저장공간 할당을 많이 하더라도 비교적 무리가 덜간다.
여러 함수들 사이를 참조하는 경우나 재귀함수처럼 자신을 여러번 참조하는 경우 모두 lifo구조에 따른다.

활성 레코드 : 스택이 저장되는 공간
함수 호출을 구현 하기 위한 자료구조는 스택프레임 = 활성 레코드라고 부른다. 그냥 이름이 다른거니까!
함수호출 구현하기
1. 함수 호출될 때마다 새로운 프레임에 스택을 생성한다.
2. 함수호출이 끝날 때마다 호출된 프레임을 제거한다.

여기에는 지역변수 매개변수 반환값 반환주소등 여러 정보가 들어간다.

스택에서 피호출자 활성레코드 바로 아래에 있는 활성레코드를 호출자 활성레코드라고 한다. 곧 불리고 없어질 애라서 호출자라고 불리나보다
스택 구조는 다음과 같이 메모리가 구분된다
반환 값
지역변수
매개변수 -> 전달 매커니즘 : call by value / result -> 전달되는 방식을 위해 필요한 것들
반환주소(에 저장) -> 나를 불러준 함수, 활성 레코드로 돌아간다.
제어링크 

이렇게 구성이 되어있다. 제어링크는 피호출자 레코드 바로 아래에 위치해 다음 호출자인 레코드를 가리킨다.

그 다음 

정적영역
stack
heap

이렇게 나눠져 있는데
heap은 버퍼 역할을 한다. stack과 heap은 영역을 처리하는 비율이 반비례한다.

1. 인터프리터 : 목적코드 사용 안함
2. 컴파일러 : 목적코드 사용 
두개로 나눠서 구분할거야
-> 뭐가 중요해? 메모리 사용법이 상이해짐


호출
활성레코드
stack에 들어감 


------------
예제(글로 써보기)


9.2 인터프리터에서 구현
인터프리터에서 함수를 구현하려면 상태를 실행시간 스택 상태로 관리를 해야한다.
이 인터프리터는 함수 정의를 먼저 만나고 나중에 함수 호출을 만날 것이다.
이 인터프리터는 함수의 정의를 만나면 그 함수의 실행 코드를 ast형태로 만들 것이다.
왜냐면 나중에 함수 호출을 만났을 때 이 함수 실행을 하기 위해서이다.

1. 상태를 스택형태로 만든다.
2. 함수 정의를 만나면 스택에 push 한다.(함수이름, 함수의 ast를 할당)
3. 함수호출을 만나면 새로운 스택프레임을 할당한다.
4. 함수 반환을 만나면 스택 프레임을 제거한다.

함수 정의
1. 그 함수의 실행코드를 기억하기 위해서 샐행시간 스택에 함수이름과 함수의 ast를 push한다.

함수 호출
1. 스택에서 호출된 코드 ast를 찾는다.
2. 스택에 프레임을 구성하고 인자를 계산해서 매개변수에 전달한다.
3. 호출된 함수의 본체를 실행
4. 함수가 저장되면 스택 탑에 저장된 값을 반환
5. 함수 호출이 종료된 후 프레임을 삭제

함수 반환
1. 수식의 값을 계산하고 이 값을 스택 프레임의 반환 값으로 지정

반환값이 있는경우 일종의 수식->수식 값을 계산하여 출력한다.

반환값이 없는 경우 일종의 문장-> 문장 실행 호출 함수 eval()에서 추적된다.

함수호출을 하기 위해서는 어떤 것들이 필요할까?
1. 스택에 저장된 ast를 가져온다.
2. 스택에 프래임 형성 + 인자값 계산 = 매개변수에 저장
3. 호출 함수의 본체 실행
4. 함수가 반환되면 스택에 탑에 저장해둔 값을 반환한다.
5. 함수호출이 끝난 후 프레임을 삭제

프레임 구성과 매개변수 전달
1. 인자 값들을 계산
2.매개변수들을 위한 기억 장소 할당
3. 인자 값들을 매개변수에 전달
4. 반환값을위한 기억장소를 매개변수 바로 위에 추가

함수 반환
수식의 값을 계산하고 이 값을 반환 값으로 스택 탑에 저장한다.

유효범위 규칙 구현


인터프리터에서는 변수를 만나면 스택의 탑부터 해당변수를 찾아서 접근한다. 따라서 이런 경우 지녀변수 x를 먼저 찾게 되어 접근 한다.
-> 자연스레 동적 유효범위 규칙이 적용되는 것이다

접근할 변수 찾기
1. 최상위스택에서 찾기 -> 여기서 차즈며 그 변수는 지역변수
2. 여기서 못찾으면 전역변수임
3. 스택내의 지역변수가 저장되는 최상위 스택 프레임과 전역변수가 저장되는 전역변수 영역의 엄격한 구분이 중요

9.3 컴파일러에서 함수구현

메모리 영역
메모리의 구성
1. 레지스터
2. 코드
3. 실행시간 스택
4. 힙
5. 데이터

코드 영역 : 프로그램을 구성하는 기계어 코드를 저장한다.

실행시간 스택 : 함수호출을 위한 지여/매개변수 반환 값, 반환 주소 등을 포함하고 있는 공간

데이터 : 동적 메모리 할당을 위한 기억공간

힙 : 정적 변수와 지역 변수들을 위해 할당된 공간
pc-> 다음 실행할 명령어의 위치를 가리킨다.
fp -> 함수 호출을 구현하기 위한 실행시간 스택 내 기억 공간을 가리킨다. 이는 활성 레코드 또는 스택 프레임이라고 불리기도 함
in C -> malloc()
in java -> new()


비지역 변수와 정적 유효범위 규칙 구현
제어링크 : 함수의 호출관계를 나타냄. 호출자의 활성 레코드에 대한 포인터를 저장한다.
= 동적링크
블록의 중첩 : 중첩해서 함수를 정의하는 것을 말함
비 지역 변수 : 지역 변수가 아닌 변수, 전역 변수를 의미하는 것은 아니다. 전역 변수는 비지역 변수이지만 비지역 변수는 지역 변수가 아닐 경우도 존재
접근링크 : 정적 유효범위 규칙을 구현하기 위해서 또하나의 링크를 사용하는 데 이것이 접근 링크
정적 유효 번위 규칙을 사용하는 경우 비 지역 변수를 접근하는데 사용된다. 
= 정적 링크 

정적 유효범위 규칙 적용 확인
프로그램 내 정의 함수와 이 함수를 정의한 비깥 블록 사이의 관계를 파악해야한다. 왜?
바깥 블록에서 선언된 변수는 함수 내의 비지역변수로 사용될 수 있기 때문이다.

비 지역 변수를 찾아 접근하기 위해서는 어떻게 해야할까?
여러번 접근 링크를 따라 나와야함 : 접근 체인

반환 값
지역 변수
매개 변수
반환 주소
접근 링크
제어 링크











