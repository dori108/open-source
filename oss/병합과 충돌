1. 병합
브랜치를 생성하는 목적 : 
원본코드에 영향을 주지 않고 분리하여 개발하기
독립된 브랜치에서 개발 작업이 끝나면 다시 원본 브랜치에 작업한 결과를 반영해야함

분리된 두 브랜치를 하나로 합치는 것이 병합이다.
하나씩 직접 비교하여 합칠 수도 있고 명령어를 이용하여 합칠 수도 있다.
(1) 수동 병합 : 양쪽파일 일일이 찾아 바뀐점을 확인하고 유용한 쪽을 선택한다.
오류 없이 병합하기 쉽지 않음
여러 개발자와 코드를 공유하며 변경 코드를 병합하는 것은 매우 어려움
복제하여 작업하고 합치는 방식을 많이 이용한다.

(2) 자동 병합 - 깃을 이용해서 : 충돌을 주의하면 어렵지 않음
깃의 병합은 브랜치를 기반으로 실행함 
각 브랜치를 비교하고 합치는 것인데 병합하려면 브랜치를 2개 이상 만들어서 그 안에서 수정작업을 해야함
여러 방식을 이용하여 병합하는데
fast-forword 병합
3-way 병합 이렇게 두 가지가 있다.

병합 실습하기
cd 실습 폴더
mkdir  폴더
cd 폴더
git init : 초기화
code index.htm : 수정작업 진행
git add . :전체 파일 등록 스테이징 하기
git commit -m “”: 커밋
그럼 이제 커밋 하나가 master에 생긴 꼴이 되는 것이지

fast-forword 병합
브랜치 생성과 수정작업이 필요하다
git branch feature : 브랜치 생성
git checkout feature : 이 브랜치로 이동하기
git rev-phase feature : 브랜치 커밋 확인
**이 명령어가 뭔지 정확히 알아야한다
이제 분기가 하나 더 생겼지 지금 -> 병합을 하려면 수정된 부분이 있어야한다.
지금은 같은 위치에 서있기 때문에 파일 수정을 해주고 애드 커밋도 해준다.
git commit -am ”” : 애드 커밋 한번에
그럼 이제 다른 부분이 생기지
이렇게되면 소스트리에서 확인해봐도 다른 위치에 두 분기가 존재한다.
한 세번더 작업하면 노드가 3개가 존재하게 되겠지? 이제 로그를 확인 해본다.
git log : 로그확인
소스 트리에서 확인해도 이제 노드가 많이 생성되었기 때문에 두 브랜치 사이 간격이 꽤나 벌어짐 -> 이런 두갈래의 브랜치 병합은 fast-forword 방식을 많이 이용한다.
이제 병합을 하기 위해서는 원래 브랜치 master main 등으로 돌아가야한다.

git checkout master 그리고 merge 
git merge feature
git log -1
로그를 확인해보면 한번 두개 브랜치가 합쳐진 것을 확인할 수 있다.

3-way
세가지 갈래를 병합할 때 이용할 수 있는 방법을 찾아보는 것 
git checkout -b hotfix
이제 새로 만든 브랜치에서 작업을 해 수정을 하는거야
git commit -am “add footer” 커밋까지 확실하게 
이 작업을 열심히 몇 번 더 반복을 하는거야 -> 다시 master 브랜치로 이동해서 git checkout master
여기서도 작업을 해주는거야 그럼 이제 세 갈래로 갈라지는거지 -> 공통 조상이 두 개야 이때 사용할 수 있는 3-way (병합 커밋은 부모 커밋이 2개라는 특징이 있음)
git merge hotfix : master에서 이 명령어를 하는거야
그러면 병합이 되는데 하나의 노드가 하나 더 생긴다.
git log -1 : 로그 확인 그러면 merge branch hotfix 라는 메세지가 뜬다
 
병합 메시지
3-way 병합은 Fast-Forward 병합과 달리 병합 메시지가 필요함 “Merge branch ‘hotfix’”라고 커밋 메시지가 자동 삽입된 것을 확인할 수 있음
병합할 때 자동으로 커밋 케세지를 만드는데, 자동으로 작성되는 메시지 외에 직접 커밋 메시지를 작성할 수도 있음
merge 명령어를 실행할 때 -e 또는 --edit 옵션을 사용하면 새로운 메세지를 입력할 수 있는 편집기가 열린다.
git merge 브랜치 이름 --edit
git reset --hard HEAD^ : 병합 취소 리셋이잖아 -> 간제로 해야하는거니까 hard 가장 앞쪽에 있던 머리를 삭제 
git merge hotfix --edit : 병합명령 + 메시지를 추가할 수 있는 에디터 

브랜치 삭제 : 병합을 마친 브랜치는 삭제해야한다. 그래야 깔끔하게 작성이 되지
git branch -d 브랜치 이름 : 삭제하는 명령어는 보통 d/ 강제하는 명령어는 f
병합을 완료하지 않은 브랜치는 -D를 이용하여 처리해줘야한다.

충돌 
대부분의 충돌 원인은 같은 위치의 코드를 동시에 수정했기 때문임 -> 다른 부분을 수정하면 문제 없음 -> 충돌 발생시 직접 수정하여 충돌을 해결하라고 요청함 
git checkout -b footer 새로운 브랜치 생성 + 이동하기
이 안에서 파일 수정을 하는거야
그리고 등록, 커밋 -> git commit -am “edit footer”
git checkout master 
파일 수정
git commit -am “edit copyright”
git merge footer 
충돌 발생 
이렇게 되면 커밋하지 않은 변경사항이라고 뜨면서 자동으로 커밋이 생성되지않는다
충돌이 발생하면 깃은 충돌 메시지를 출력하고 병합 작업을 중단함
현재 워킹 디렉토리에 있는 사항이 있다는 것이기 때문에 git status로 확인을 해보면 된다.
어떤 파일이 작업중인지가 확인할 수 있음
이런 경우 수동으로 해결해야한다.
다시 
git add 수정한 파일
git commit -m”resolve complicit” 병합 커밋
이후 확인하면 충돌이 해결된 것을 확인할 수 있다.

리베이스
리베이스는 병합과 달리 새로운 하나의 노드를 만드는 것이 아니야. 
master 브랜치의 head에 브랜치의 작업을 이어 붙여서 하나로 통일 시키는 것이다.
모든 브랜치는 뿌리가 있음(master 브랜치는 예외임)브랜치는 특정 커밋을 가리키는 포인터임 
가리키는 특정 커밋은 브랜치가 파생된 기준이 됨(부모가 되는 것이다.) 얘를 베이스라고 한다.
브랜치는 커밋 하나를 기준으로 새로운 작업을 진행할 수 있는 분리된 작업경로를 의미함
너무 브랜치가 많아지면 꼬여서 관리하기가 힘들어 이런 경우에는 베이스를 변경시켜서 조금 더 간략하게 바꿔주는것
리베이스는 두 브랜치를 서로 비교하지 않고 순차적으로 커밋 병합을 시도함
리베이스에서 브랜치의 커밋을 결합하는 순서
1. 리베이스를 하면 먼저 공통 조상 커밋을 찾음 
2. 리베이스는 베이스 커밋을 변경하여 두 브랜치의 커밋 위치를 바꿈
3. 파생된 브랜치의 diff를 임시 공간에 잠시 보관함
4. 기존 베이스에서 가장 마지막에 master에서 커밋된 노드로 베이스 기준점을 변경함
5. 변경하는 기준 브랜치의 마지막 커밋에서 차례로 임시 공간에 저장한 diff를 하나씩 적용함 
6. 새로운 베이스 기준점을 기반으로 한 브랜치에서 master가 아닌 다른 브랜치에서 만들어진 커밋을 연결시킴 -> 수정 재배치함

그럼 이제 한 줄이 되겠지
리베이스는 병합 기준 브랜치가 merge 명령어와 반대야 
원래는 원본 브랜치에 파생 브랜치의 변경 사항을 병합 시키는데 리베이스는 병합 방향이 반대야 

명령어
파생 브랜치에서 명령어를 입력한다.
git rebase master 같이 
명령어 입력하는 브랜치가 다르지?
리베이스는 베이스를 바꾸기 때문에 커밋의 해쉬값이 변한다. -> 배포 뒤에는 안하는 것이 좋음
git log -3 : 로그 확인
최근 세개의 로그를 확인할 수 있다. 일반적으로 병합 뒤에는 같은 커밋 id를 가리키는데 이 경우에는 달라. 리베이스는 커밋 위치를 조정하는 것일 뿐이지 head의 위치를 갘게 만들어주진 않는다. 이것을 해걀하기 위해서는 리베이스 후 병합을 해줘야한다.
!!!!!

git checkout master
git merge 새로만든 브랜치 이름
이렇게한 뒤에나 이제 완성이 되는 것이다.
리베이스한 후에 실행한 병합 메시지도 Fast-Forward 방식으로 병합한다
리베이스한 후 HEAD 포인터의 위치 모양은 Fast-Forward 병합을 실습할 때와같은 형태임 
리베이스는 커밋을 재배치만 할 뿐 실제 병합과 같은 최종 상태는 가지지 않음 
리베이스한 후에도 HEAD 포인터를 일치하기 위해 Fast-Forward 병합을 실행해주어야 함 
두 브랜치의 HEAD를 일치시키는 작업까지 해야 최종 병합을 완성할 수 있음

git branch -d 새로 만든 브랜치 
필요없는 브랜치는 삭제 처리

리베이스 충돌과 해결
git checkout -b menu
파일수정
등록, 커밋
몇번 반복 후 원본 브랜치로 이동 
여기서도 파일을 수정하면 충돌이 일어남
다시 menu 브랜치로 이동 
git rebase master -> 충돌한다. 리베이스하지 못한다.
메뉴에서 파일을 수정해줘야한다. 충돌하는 부분을 -> 수작업
git add 수정한 파일
git rebase --continue 계속 진행 -> 이제 확인해보면 충돌이 수정되었을 것이다
git checkout master 이동도 가능해






